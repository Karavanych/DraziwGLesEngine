attribute vec4 aPosition;
attribute vec2 aTextureCoord;
attribute vec3 aNormal;

varying vec2 vTextureCoord;
varying float vDiffuse;

uniform float uLuminance;
uniform vec3 uLightPos;

uniform mat4 m,v, mvp; // model, view matrix 

void main() {

	// “рансформируем вертексы в позицию вида
	vec3 modelViewVertex = vec3(v*m * aPosition);
	
	// “рансформируем нормали в позицию вида, не будет работать если объект повернуть, нужна матрица поворота
	vec3 modelViewNormal = vec3(v * vec4(aNormal, 0.0)); 
	
	// –асчитываем дисстанцию дл€ затухани€ освещени€
	float distance = length(uLightPos - modelViewVertex);
	
	// ѕолучим нормализованный вектор направлени€  от источника света к вертексам
	vec3 lightVector = normalize(uLightPos - modelViewVertex);
	
	// –асчитаем скаларное произведение (dot product) вектора света и вектора нормали
   	// ћаксимальна€ €ркость будет в случае если эти ветора однонаправленные , 0.1 - минимальна€ освещенность   	
   	float diffuse = max(dot(modelViewNormal, lightVector), 0.1);
   	
   	// –ассчитаем угасание в зависимости от дистанции
   	vDiffuse = diffuse * (1.0 / (0.9 + (uLuminance * distance * distance)));
   	gl_Position = mvp*aPosition;
   	vTextureCoord = aTextureCoord;
   	
 }
   		
[FRAGMENT]

precision highp float;
varying vec2 vTextureCoord;
varying float vDiffuse;
uniform sampler2D uBaseMap;
void main() {

	gl_FragColor = texture2D(uBaseMap,vTextureCoord)*vDiffuse;
	
}